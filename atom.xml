<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夜阑卧听风吹雨的博客</title>
  
  <subtitle>心中有丘壑，眉目做山河</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-26T15:21:15.476Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zippo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA8 Date 工具类封装</title>
    <link href="http://yoursite.com/2019/04/01/java8date/"/>
    <id>http://yoursite.com/2019/04/01/java8date/</id>
    <published>2019-04-01T07:17:42.000Z</published>
    <updated>2019-03-26T15:21:15.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java8日期-时间的介绍"><a href="#Java8日期-时间的介绍" class="headerlink" title="Java8日期/时间的介绍"></a>Java8日期/时间的介绍</h1><p>Java 8 日期/时间（Date/Time）API 是开发人员最受追捧的变化之一，java从一开始就没有对日期时间处理的一致性方法，因此日期/时间API也是除Java核心API以外另一项倍受欢迎的内容。</p><h2 id="Java8-中新的时间日期API解决了什么问题？"><a href="#Java8-中新的时间日期API解决了什么问题？" class="headerlink" title="Java8 中新的时间日期API解决了什么问题？"></a>Java8 中新的时间日期API解决了什么问题？</h2><p>1.java8 之前的日期/时间类的定义不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类(SimpleDateFormat)在java.text包中定义。</p><p>2.所以的日期类都是可变的，因此他们都不是线程安全的，这是Java日期类的最大的问题之一。</p><p>3.日期类并不提供国际化。</p><p>4.月份从<strong>o</strong>开始计算。</p><h2 id="Java8-日期时间API的介绍"><a href="#Java8-日期时间API的介绍" class="headerlink" title="Java8 日期时间API的介绍"></a>Java8 日期时间API的介绍</h2><p>Java 8  日期/时间（java.time包下）主要介绍LocalDate 、 LocalTime 、 Instant 、 Duration 以及 Period</p><p>1.使用 LocalDate 和 LocalTime</p><p>①LocalDate:该类的实例是一个不可变的对象，只提供了简单的日期，并不包含当天的时间信息，也不附带任何与时区相关的信息。代码清单如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 使用localDate 静态工厂方法of 创建一个LocalDate实例</span><br><span class="line">LocalDate date = LocalDate.of(2019, 3, 26);</span><br><span class="line">// 获取年月日 API</span><br><span class="line">//年</span><br><span class="line">int year = date.getYear();</span><br><span class="line">// 月</span><br><span class="line">Month month = date.getMonth();</span><br><span class="line">// 日</span><br><span class="line">int dayOfMonth = date.getDayOfMonth();</span><br><span class="line">// 星期几</span><br><span class="line">DayOfWeek dayOfWeek = date.getDayOfWeek();</span><br><span class="line">// 这月有多少天</span><br><span class="line">int i = date.lengthOfMonth();</span><br><span class="line">// 是否为闰年</span><br><span class="line">boolean leapYear = date.isLeapYear();</span><br><span class="line">// 获取当前系统时间</span><br><span class="line">LocalDate today = LocalDate.now();</span><br></pre></td></tr></table></figure><p>②LocalTime:该类表示一天中的时间，可以通过静态工程方法of创建实例，of有两个重载的方法，第一个方法可以传入小时，分钟。第二个方法可以传入时分秒。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建 LocalTime 实例</span><br><span class="line">LocalTime time = LocalTime.of(21, 12, 20);</span><br><span class="line">//  获取小时</span><br><span class="line">int hour = time.getHour();</span><br><span class="line">// 获取分钟</span><br><span class="line">int minute = time.getMinute();</span><br><span class="line">// 获取 秒</span><br><span class="line">int second = time.getSecond();</span><br></pre></td></tr></table></figure><p>总结：LocalTime和LocalDate都可以通过解析代表他们的字符串创建，使用静态方法parse,如若传递的字符串无法被解析为合法的LocalDate和LocalTime 就会抛出一个继承与RuntimeException的DateTimePaseException异常。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalTime time = LocalTime.parse(&quot;21:19:00&quot;);</span><br><span class="line">LocalDate date = LocalDate.parse(&quot;2019-3-26&quot;);</span><br></pre></td></tr></table></figure><p>2.LocalDateTime:该类是LocalDate和LocalTime的合体。它同时表示了日期和时间，但不带有时区信息。</p><p>①创建LocalDateTime 对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalTime time = LocalTime.parse(&quot;21:19:00&quot;);</span><br><span class="line">LocalDate date = LocalDate.parse(&quot;2019-3-26&quot;);</span><br><span class="line">LocalDateTime dateTime = LocalDateTime.of(2019, 3, 26, 21, 26, 55);</span><br><span class="line">LocalDateTime dateTime1 = LocalDateTime.of(date, time);</span><br><span class="line">LocalDateTime dateTime2 = date.atTime(21, 28, 45);</span><br><span class="line">LocalDateTime dateTime3 = date.atTime(time);</span><br><span class="line">LocalDateTime dateTime4 = time.atDate(date);</span><br></pre></td></tr></table></figure><p>②从LocalDateTime中提取出LocalDate和LocaTime:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate = dateTime.toLocalDate();</span><br><span class="line">LocalTime localTime = dateTime.toLocalTime();</span><br></pre></td></tr></table></figure><p>3.Instant :该类表示的是距离UTC时区1970年1月1日午夜时分的毫秒数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 获取当前时间戳</span><br><span class="line">Instant now = Instant.now();</span><br><span class="line">//获取当前的时间，获取的是当前的美国时间，和处于东八区的我们相差八个小时。</span><br><span class="line">System.out.println(now);//  输出结果 ：2019-03-26T13:53:42.642Z</span><br><span class="line">// 设置偏移量</span><br><span class="line">OffsetDateTime offsetDateTime = now.atOffset(ZoneOffset.ofHours(8));</span><br><span class="line">System.out.println(offsetDateTime);// 输出结果 2019-03-26T21:56:20.915+08:00</span><br><span class="line">// 获取默认时区时间</span><br><span class="line">ZonedDateTime zonedDateTime = now.atZone(ZoneId.systemDefault());</span><br><span class="line">System.out.println(zonedDateTime); // 输出结果 2019-03-26T22:00:24.783+08:00[Asia/Shanghai]</span><br><span class="line">//在计算机元年（1970-01-01  00：00：00）的基础上增加秒数</span><br><span class="line">Instant instant = Instant.ofEpochSecond(200);</span><br><span class="line">System.out.println(instant); // 输出结果 ：1970-01-01T00:03:20Z</span><br></pre></td></tr></table></figure><p>4.Duration:该类是用来表示时间之间间隔，经常和Instant集合起来使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Instant inst1 = Instant.now();</span><br><span class="line">System.out.println(&quot;Inst1 : &quot; + inst1); // Inst1 : 2019-03-26T14:21:14.343Z</span><br><span class="line">Instant inst2 = inst1.plus(Duration.ofSeconds(10));</span><br><span class="line">System.out.println(&quot;Inst2 : &quot; + inst2); // Inst2 : 2019-03-26T14:21:24.343Z</span><br><span class="line">System.out.println(&quot;Difference in milliseconds : &quot; + Duration.between(inst1, inst2).toMillis()); //Difference in milliseconds : 10000</span><br><span class="line">System.out.println(&quot;Difference in seconds : &quot; + Duration.between(inst1, inst2).getSeconds());  // Difference in seconds : 10</span><br></pre></td></tr></table></figure><p>5.Period：用来计算日期之间的间隔，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">System.out.println(&quot;Today : &quot; + today); // Today : 2019-03-26</span><br><span class="line">LocalDate birthDate = LocalDate.of(1995, Month.OCTOBER, 19);</span><br><span class="line">System.out.println(&quot;BirthDate : &quot; + birthDate); // BirthDate : 1995-10-19</span><br><span class="line">Period p = Period.between(birthDate, today);</span><br><span class="line">System.out.printf(&quot;年龄 : %d 年 %d 月 %d 日&quot;, p.getYears(), p.getMonths(), p.getDays());// 年龄 : 23 年 5 月 7 日</span><br></pre></td></tr></table></figure><p>6.ChronoUnit：用于在单个时间单位内测量一段时间，例如天数或秒。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalDate start = LocalDate.of(1995,10, 11);</span><br><span class="line">System.out.println(&quot;开始时间：&quot;+start);//开始时间：1995-10-11</span><br><span class="line">LocalDate end = LocalDate.now();</span><br><span class="line">System.out.println(&quot;结束时间:&quot;+end);// 结束时间:2019-03-26</span><br><span class="line">long day = ChronoUnit.DAYS.between(start, end);</span><br><span class="line">System.out.println(&quot;两个时间相差多少天&quot;+day);//两个时间相差多少天8567</span><br></pre></td></tr></table></figure><h2 id="操纵，解析，格式化日期"><a href="#操纵，解析，格式化日期" class="headerlink" title="操纵，解析，格式化日期"></a>操纵，解析，格式化日期</h2><h3 id="操纵日期"><a href="#操纵日期" class="headerlink" title="操纵日期"></a>操纵日期</h3><p>1.当我们得到了一个LocalDate对象后，想要创建一个它的修改版，可以使用他的withAttribute方法。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.now();</span><br><span class="line">System.out.println(&quot;当前时间：&quot;+date); // 当前时间：2019-03-26</span><br><span class="line">LocalDate localDate = date.withYear(2018);</span><br><span class="line">System.out.println(&quot;修改年之后：&quot;+localDate); // 2018-03-26</span><br><span class="line">LocalDate localDate1 = date.withMonth(1);</span><br><span class="line">System.out.println(&quot;修改月之后的：&quot;+localDate1);// 2019-01-26</span><br></pre></td></tr></table></figure><p>2.TemporalAdjuster:使用该类完成一些复杂的业务需求，如将时间调整到下个工作日，下个周日，或者是本月的最后一天。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date1 = LocalDate.of(2019, 3, 26);</span><br><span class="line">System.out.println(&quot;当前时间：&quot;+date1);// 当前时间：2019-03-26</span><br><span class="line">LocalDate date2 = date1.with(nextOrSame(DayOfWeek.SUNDAY));</span><br><span class="line">System.out.println(&quot;下一个星期天：&quot;+date2);//下一个星期天：2019-03-31</span><br><span class="line">LocalDate date3 = date2.with(lastDayOfMonth());</span><br><span class="line">System.out.println(&quot;这个月的最后一天：&quot;+date3);//这个月的最后一天：2019-03-31</span><br></pre></td></tr></table></figure><p>更多api如下图：</p><p><img src="/2019/04/01/java8date/TemporalAdjuster.jpg" alt></p><p>3.自定义一个TemporalAdjuster：</p><p>设计一个 NextWorkingDay 类，该类实现了 TemporalAdjuster 接口，能够计算明天<br>的日期，同时过滤掉周六和周日这些节假日。格式如下所示：<br>date = date.with(new NextWorkingDay());<br>如果当天的星期介于周一至周五之间，日期向后移动一天；如果当天是周六或者周日，则<br>返回下一个周一。代码如下：</p><h3 id="解析，格式化日期"><a href="#解析，格式化日期" class="headerlink" title="解析，格式化日期"></a>解析，格式化日期</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java8日期-时间的介绍&quot;&gt;&lt;a href=&quot;#Java8日期-时间的介绍&quot; class=&quot;headerlink&quot; title=&quot;Java8日期/时间的介绍&quot;&gt;&lt;/a&gt;Java8日期/时间的介绍&lt;/h1&gt;&lt;p&gt;Java 8 日期/时间（Date/Time）API
      
    
    </summary>
    
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
  </entry>
  
</feed>
